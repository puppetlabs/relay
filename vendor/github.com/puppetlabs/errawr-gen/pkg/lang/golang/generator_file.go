package golang

import (
	"fmt"
	"go/token"
	"io"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/puppetlabs/errawr-gen/pkg/doc"
	"github.com/serenize/snaker"
)

const (
	public  = "github.com/puppetlabs/errawr-go/v2/pkg/errawr"
	private = "github.com/puppetlabs/errawr-go/v2/pkg/impl"
)

func argumentGoName(name string) string {
	candidate := snaker.SnakeToCamelLower(name)
	if token.Lookup(candidate).IsKeyword() {
		candidate += "_"
	}

	return candidate
}

func argumentType(a *doc.DocumentErrorArgument) jen.Code {
	if a == nil {
		return jen.String()
	}

	switch a.Type {
	case "string":
		return jen.String()
	case "number":
		return jen.Float64()
	case "integer":
		return jen.Int64()
	case "boolean":
		return jen.Bool()
	case "list<string>":
		return jen.Index().String()
	case "list<number>":
		return jen.Index().Float64()
	case "list<integer>":
		return jen.Index().Int64()
	case "list<boolean>":
		return jen.Index().Bool()
	default:
		return jen.String()
	}
}

func errorSensitivity(sensitivity string) jen.Code {
	switch sensitivity {
	case "all":
		return jen.Qual(public, "ErrorSensitivityAll")
	case "bug":
		return jen.Qual(public, "ErrorSensitivityBug")
	case "edge":
		return jen.Qual(public, "ErrorSensitivityEdge")
	default:
		return jen.Qual(public, "ErrorSensitivityNone")
	}
}

type Error struct {
	Section    Section
	Name       string
	GoName     string
	Definition doc.DocumentError
}

type Section struct {
	Name       string
	GoName     string
	Definition doc.DocumentSection
}

type FileGenerator struct {
	pkg string
	doc *doc.Document
	f   *jen.File
}

func (fg *FileGenerator) init() {
	fg.f.PackageComment(fmt.Sprintf("Package %s contains errors for the domain %q.", fg.pkg, fg.doc.Domain.Key))
	fg.f.PackageComment("")
	fg.f.PackageComment("This file is automatically generated by errawr-gen. Do not modify it.")

	// Create an interface type inheriting the public Errawr error interface.
	fg.f.Comment("Error is the type of all errors generated by this package.")
	fg.f.Type().Id("Error").Interface(jen.Qual(public, "Error"))

	// Create a type and instance for public (external to package) APIs for
	// these errors.
	fg.f.Comment("External contains methods that can be used externally to help consume errors from this package.")
	fg.f.Type().Id("External").Struct()

	fg.f.Comment("API is a singleton instance of the External type.")
	fg.f.Var().Id("API").Id("External")

	// Create a type for the domain.
	fg.f.Comment("Domain is the general domain in which all errors in this package belong.")
	fg.f.Var().Id("Domain").Op("=").Op("&").Qual(private, "ErrorDomain").Values(jen.Dict{
		jen.Id("Key"):   jen.Lit(fg.doc.Domain.Key),
		jen.Id("Title"): jen.Lit(fg.doc.Domain.Title),
	})
	fg.f.Line()
}

func (fg *FileGenerator) def(def Error) {
	// We may want to use the code internally, so create it here.
	codeTypeName := fmt.Sprintf(`%s%sCode`, def.Section.GoName, def.GoName)

	fg.f.Commentf(`%s is the code for an instance of %q.`, codeTypeName, def.Name)
	fg.f.Const().Id(codeTypeName).Op("=").Lit(fmt.Sprintf(`%s_%s_%s`, fg.doc.Domain.Key, def.Section.Name, def.Name))
	fg.f.Line()

	// Create a convenience function that can test the error against its code.
	testFuncName := fmt.Sprintf(`Is%s%s`, def.Section.GoName, def.GoName)

	fg.f.Commentf(`%s tests whether a given error is an instance of %q.`, testFuncName, def.Name)
	fg.f.Func().Id(testFuncName).Params(
		jen.Id("err").Qual(public, "Error"),
	).Bool().Block(
		jen.Return(jen.Id("err").Op("!=").Nil().Op("&&").Id("err").Dot("Is").Call(jen.Id(codeTypeName))),
	)

	fg.f.Commentf(`%s tests whether a given error is an instance of %q.`, testFuncName, def.Name)
	fg.f.Func().Params(jen.Id("External")).Id(testFuncName).Params(
		jen.Id("err").Qual(public, "Error"),
	).Bool().Block(
		jen.Return(jen.Id(testFuncName).Call(jen.Id("err"))),
	)

	// Create the builder type.
	builderTypeName := fmt.Sprintf(`%s%sBuilder`, def.Section.GoName, def.GoName)

	// Builder type fields are inserted into the builder struct.
	var builderTypeFields []*jen.Statement

	// Builder initializers for the above type fields.
	var builderInitializers []func(jen.Dict)

	// Builder methods are additional methods to add to the builder type.
	var builderMethods []func(*jen.Group)

	// Type initializers map builder type fields to the error implementation.
	var typeInitializers []func(jen.Dict)

	for _, trait := range def.Definition.Traits {
		switch trait {
		case "container":
			// Container trait allows existing errors to be mapped as validation
			// errors.
			builderTypeFields = append(builderTypeFields, jen.Id("items").Qual(private, "ErrorItems"))
			builderInitializers = append(builderInitializers, func(d jen.Dict) {
				d[jen.Id("items")] = jen.Qual(private, "ErrorItems").Values()
			})
			builderMethods = append(builderMethods, func(g *jen.Group) {
				g.Commentf(`// SetItem sets a contained error in this builder.
//
// The path should be an expression of the form "parent.child[1].field" that
// uniquely identifies the location of the error in an input object.`)
				g.Func().Params(
					jen.Id("b").Op("*").Id(builderTypeName),
				).Id("SetItem").Params(
					jen.Id("path").String(),
					jen.Id("err").Qual(public, "Error"),
				).Op("*").Id(builderTypeName).Block(
					jen.Id("b").Dot("items").Index(jen.Id("path")).Op("=").Id("err"),
					jen.Return(jen.Id("b")),
				)
				g.Line()
			})
			typeInitializers = append(typeInitializers, func(d jen.Dict) {
				d[jen.Id("ErrorItems")] = jen.Id("b").Dot("items")
			})
		}
	}

	fg.f.Commentf(`%s is a builder for %q errors.`, builderTypeName, def.Name)
	fg.f.Type().Id(builderTypeName).StructFunc(func(g *jen.Group) {
		g.Id("arguments").Qual(private, "ErrorArguments")

		for _, field := range builderTypeFields {
			g.Add(field)
		}
	})
	fg.f.Line()

	// Create builder methods for all optional arguments.
	for _, a := range def.Definition.OrderedArguments {
		if !a.Argument.IsOptional() {
			continue
		}

		withFuncName := fmt.Sprintf(`With%s`, snaker.SnakeToCamel(a.Name))

		description := a.Argument.Description
		if description == "" {
			description = fmt.Sprintf("the %q argument", a.Name)
		}

		fg.f.Commentf(`%s sets %s in this builder.`, withFuncName, description)
		fg.f.Func().Params(
			jen.Id("b").Op("*").Id(builderTypeName),
		).Id(withFuncName).Params(
			jen.Id("value").Add(argumentType(a.Argument)),
		).Op("*").Id(builderTypeName).Block(
			jen.Id("b").Dot("arguments").Index(jen.Lit(a.Name)).Dot("Set").Call(jen.Id("value")),
			jen.Return(jen.Id("b")),
		)
		fg.f.Line()
	}

	for _, method := range builderMethods {
		method(fg.f.Group)
	}

	// Create final Build() method.
	fg.f.Commentf(`Build creates the error for the code %q from this builder.`, def.Name)
	fg.f.Func().Params(
		jen.Id("b").Op("*").Id(builderTypeName),
	).Id("Build").Params().Id("Error").BlockFunc(func(g *jen.Group) {
		// Add runtime argument validation.
		for _, a := range def.Definition.OrderedArguments {
			if a.Argument == nil || len(a.Argument.Validators) == 0 {
				continue
			}

			for _, validator := range a.Argument.Validators {
				g.Id("b").Dot("arguments").Index(jen.Lit(a.Name)).Dot("Validate").Call(jen.Lit(validator))
			}
			g.Line()
		}

		g.Id("description").Op(":=").Op("&").Qual(private, "ErrorDescription").Values(jen.Dict{
			jen.Id("Friendly"):  jen.Lit(strings.TrimSpace(def.Definition.Description.Friendly)),
			jen.Id("Technical"): jen.Lit(strings.TrimSpace(def.Definition.Description.Technical)),
		})
		g.Line()

		g.Return(jen.Op("&").Qual(private, "Error").Values(jen.DictFunc(func(d jen.Dict) {
			d[jen.Id("Version")] = jen.Lit(1)
			d[jen.Id("ErrorDomain")] = jen.Id("Domain")
			d[jen.Id("ErrorSection")] = jen.Id(fmt.Sprintf(`%sSection`, def.Section.GoName))
			d[jen.Id("ErrorCode")] = jen.Lit(def.Name)
			d[jen.Id("ErrorTitle")] = jen.Lit(def.Definition.Title)
			d[jen.Id("ErrorDescription")] = jen.Id("description")
			d[jen.Id("ErrorArguments")] = jen.Id("b").Dot("arguments")
			d[jen.Id("ErrorMetadata")] = jen.Op("&").Qual(private, "ErrorMetadata").Values(jen.DictFunc(func(d jen.Dict) {
				if def.Definition.Metadata.HTTP != nil {
					d[jen.Id("HTTPErrorMetadata")] = jen.Op("&").Qual(private, "HTTPErrorMetadata").Values(jen.Dict{
						jen.Id("ErrorStatus"): jen.Lit(def.Definition.Metadata.HTTP.Status),
						jen.Id("ErrorHeaders"): jen.Qual(private, "HTTPErrorMetadataHeaders").Values(jen.DictFunc(func(d jen.Dict) {
							for _, h := range def.Definition.Metadata.HTTP.OrderedHeaders {
								d[jen.Lit(h.Name)] = jen.Index().String().ValuesFunc(func(g *jen.Group) {
									for _, v := range h.Values {
										g.Lit(v)
									}
								})
							}
						})),
					})
				}
			}))
			d[jen.Id("ErrorSensitivity")] = errorSensitivity(def.Definition.Sensitivity)

			for _, init := range typeInitializers {
				init(d)
			}
		})))
	})
	fg.f.Line()

	// Create constructors.
	constructorFuncName := fmt.Sprintf(`New%s`, builderTypeName)
	params := func(g *jen.Group) {
		for _, a := range def.Definition.OrderedArguments {
			if a.Argument.IsOptional() {
				continue
			}

			g.Id(argumentGoName(a.Name)).Add(argumentType(a.Argument))
		}
	}

	fg.f.Commentf(`%s creates a new error builder for the code %q.`, constructorFuncName, def.Name)
	fg.f.Func().Id(constructorFuncName).ParamsFunc(params).Op("*").Id(builderTypeName).Block(
		jen.Return(jen.Op("&").Id(builderTypeName).Values(jen.DictFunc(func(d jen.Dict) {
			d[jen.Id("arguments")] = jen.Qual(private, "ErrorArguments").Values(jen.DictFunc(func(d jen.Dict) {
				for _, a := range def.Definition.OrderedArguments {
					d[jen.Lit(a.Name)] = jen.Qual(private, "NewErrorArgument").Call(jen.Do(func(s *jen.Statement) {
						if a.Argument.IsOptional() {
							s.Lit(a.Argument.Default)
						} else {
							s.Id(argumentGoName(a.Name))
						}
					}), jen.LitFunc(func() interface{} {
						if a.Argument == nil {
							return ""
						}

						return a.Argument.Description
					}))
				}
			}))

			for _, init := range builderInitializers {
				init(d)
			}
		}))),
	)
	fg.f.Line()

	defaultFuncName := fmt.Sprintf(`New%s%s`, def.Section.GoName, def.GoName)

	fg.f.Commentf(`%s creates a new error with the code %q.`, defaultFuncName, def.Name)
	fg.f.Func().Id(defaultFuncName).ParamsFunc(params).Id("Error").Block(
		jen.Return(
			jen.Id(constructorFuncName).CallFunc(func(g *jen.Group) {
				for _, a := range def.Definition.OrderedArguments {
					if a.Argument.IsOptional() {
						continue
					}

					g.Id(argumentGoName(a.Name))
				}
			}).Dot("Build").Call(),
		),
	)
	fg.f.Line()
}

func (fg *FileGenerator) section(section Section) {
	// Create a type for the section.
	sectionTypeName := fmt.Sprintf(`%sSection`, section.GoName)

	fg.f.Commentf(`%s defines a section of errors with the following scope:`, sectionTypeName)
	fg.f.Comment(section.Definition.Title)
	fg.f.Var().Id(sectionTypeName).Op("=").Op("&").Qual(private, "ErrorSection").Values(jen.Dict{
		jen.Id("Key"):   jen.Lit(section.Name),
		jen.Id("Title"): jen.Lit(section.Definition.Title),
	})
	fg.f.Line()

	names := make([]string, len(section.Definition.Errors))

	i := 0
	for name := range section.Definition.Errors {
		names[i] = name
		i++
	}

	sort.Strings(names)

	for _, name := range names {
		fg.def(Error{
			Section:    section,
			Name:       name,
			GoName:     snaker.SnakeToCamel(name),
			Definition: section.Definition.Errors[name],
		})
	}
}

func (fg *FileGenerator) all() {
	names := make([]string, len(fg.doc.Sections))

	i := 0
	for name := range fg.doc.Sections {
		names[i] = name
		i++
	}

	sort.Strings(names)

	for _, name := range names {
		fg.section(Section{
			Name:       name,
			GoName:     snaker.SnakeToCamel(name),
			Definition: fg.doc.Sections[name],
		})
	}
}

func (fg *FileGenerator) Render(w io.Writer) error {
	return fg.f.Render(w)
}

func NewFileGenerator(pkg string, document *doc.Document) *FileGenerator {
	fg := &FileGenerator{
		pkg: pkg,
		doc: document,
		f:   jen.NewFile(pkg),
	}
	fg.init()
	fg.all()

	return fg
}
